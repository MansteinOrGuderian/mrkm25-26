\section{Introduction}

Інформаційна безпека стала критично важливим питанням у сучасних обчислювальних системах, де передача та зберігання
конфіденційних даних вимагають надійних механізмів захисту. Криптографічні системи є основою інформаційної безпеки,
забезпечуючи конфіденційність, цілісність, автентифікацію та незаперечність дій~\cite{stallings2017}.

В лабораторній роботі я розглянув особливості існуючих програмних систем, що реалізують криптографічні механізми,
з особливим акцентом на асиметричній криптографії, стандартизованих інтерфейсах та оцінці вразливості. Еволюція
криптографічного програмного забезпечення призвела до розробки стандартизованих інтерфейсів прикладного програмування
(API), таких як CryptoAPI від Microsoft та стандарти криптографії з відкритим ключем (PKCS), розроблені RSA Laboratories.
Ці стандарти сприяють взаємодії між різними криптографічними реалізації та забезпечення послідовних властивостей безпеки
на різних платформах~\cite{pkcs1,cryptoapi}.

Ця теоретична основа створює контекст для практичної реалізації криптографічних систем, зокрема і криптосистеми ElGamal
з використанням бібліотеки OpenSSL, та дослідження потенційних вразливостей у криптографічних провайдерах, які можуть
виникнути через недосконалість механізмів захисту операційної системи.

\section{Fundamentals of Cryptographic Systems}

\subsection{Класифікація криптографічних алгоритмів}

Криптографічні алгоритми широко класифікуються на дві категорії: симетрична та асиметрична криптографія. Симетричні
алгоритми, такі як AES та DES, використовують один і той самий ключ для операцій шифрування та розшифрування. Хоча
симетричні системи є обчислювально ефективними, вони стикаються з проблемою безпечного розподілу ключів~\cite{ferguson2010}.

Асиметрична криптографія або криптографія з відкритим ключем вирішує проблему розподілу ключів за допомогою математично
пов'язаних пар ключів: відкритого ключа для шифрування та закритого ключа для розшифрування. Безпека асиметричних систем
базується на припущені про обчислювальну складність, таких як складність розкладання великих цілих чисел на множники
(RSA) або обчислення дискретних логарифмів (ElGamal, DSA)~\cite{menezes1996}.

\subsection{Криптосистема ElGamal}

Криптосистема ElGamal, запропонована Тахером ЕльГамалем у 1985 році, базується на проблемі дискретного логарифму в
скінченних полях~\cite{elgamal1985}. Система працює в мультиплікативній групі цілих чисел за модулем великого простих
числа $p$, де проблема дискретного логарифму вважається обчислювально нерозв'язною.

\textbf{Генерація ключа:}
\begin{enumerate}
    \item Виберати велике просте число $p$ та генератор $g$ мультиплікативної групи $\mathbb{Z}_p^*$
    \item Виберати випадковий private key $x$, де $1 \leq x \leq p-2$
    \item Обчислити public key $y = g^x \pmod p$
    \item Public key: $(p, g, y)$; Private key: $x$
\end{enumerate}

\textbf{Шифрування:} Для зашифрування повідомлення $m$, де $0 \leq m \leq p-1$ необхідно:
\begin{enumerate}
    \item Вибрати випадковий ephemeral key $k$, де $1 \leq k \leq p-2$
    \item Обчислити $c_1 = g^k \pmod p$
    \item Обчислити $c_2 = m \cdot y^k \pmod p$
    \item Шифротекст: $(c_1, c_2)$
\end{enumerate}

\textbf{Розшифрування:} Щоб розшифрування шифротексту $(c_1, c_2)$:
\begin{equation*}
    m = c_2 \cdot (c_1^x)^{-1} \pmod p
\end{equation*}

Безпека ElGamal базується на обчислювальному припущенні Діффі-Хеллмана, що робить її стійкою до відомих криптоаналітичних
атак при правильній реалізації з достатньо великими параметрами~\cite{elgamal1985}.

\subsection{Криптографічні примітиви}

Сучасні криптографічні системи надають чотири основні security issues:

\textbf{Confidentiality} гарантує, що інформація доступна тільки уповноваженим сторонам за допомогою механізмів шифрування. 
Конфіденційність можуть забезпечувати як симетричні, так і асиметричні алгоритми, хоча асиметричні системи зазвичай 
використовуються для обміну ключами через обчислювальні накладні витрати.

\textbf{Integrity} гарантує, що інформація не була змінена під час передачі або зберігання. Хеш-функції та коди автентифікації 
повідомлень (MAC) забезпечують перевірку цілісності, не перешкоджаючи спробам модифікації.

\textbf{Authentication} перевіряє ідентичність сторін, що спілкуються. Цифрові підписи, засновані на асиметричній 
криптографії, забезпечують надійну аутентифікацію, демонструючи володіння приватним ключем, що відповідає відомому 
публічному ключу.

\textbf{Non-repudiation} запобігає спробам сторін заперечувати свої дії. Цифрові підписи забезпечують невідмовність, 
створюючи докази того, що конкретна сторона створила повідомлення~\cite{stallings2017}.

\section{Стандартизовані криптографічні інтерфейси}

\subsection{Microsoft CryptoAPI}

Криптографічний інтерфейс прикладного програмування (CryptoAPI) від Microsoft забезпечує основу для інтеграції 
криптографічних функцій у Windows додатки~\cite{cryptoapi}. Архітектура складається з декількох рівнів:

\textbf{Application рівень:} додатки взаємодіють з CryptoAPI за допомогою функцій високого рівня, які абстрагують
криптографічні операції.

\textbf{CryptoAPI рівень:} він забезпечує стандартизовані інтерфейси для криптографічних операцій,
включаючи хешування, шифрування, цифрові підписи та управління сертифікатами.

\textbf{Cryptographic Service Provider (CSP) рівень:} CSP реалізують фактичні криптографічні алгоритми. У системі може 
співіснувати декілька CSP, що дозволяє додаткам вибирати відповідних постачальників на основі вимог безпеки або 
відповідності нормативним вимогам.

Архітектура CryptoAPI підтримує як програмні, так і апаратні криптографічні реалізації. Hardware security modules 
(HSM) можуть бути інтегровані як CSP, забезпечуючи підвищений захист ключів за допомогою спеціального 
криптографічного обладнання.

Основні фічі в CryptoAPI:
\begin{itemize}
    \item Незалежність від алгоритмів завдяки provider abstraction 
    \item Підтримка криптографічних апаратних токенів
    \item Certificate-based public key infrastructure (PKI)
    \item Безпечне зберігання та управління ключами
    \item Генерація криптографічних випадкових чисел
\end{itemize}

\subsection{Public-Key Cryptography Standards (PKCS)}

Сімейство стандартів PKCS, розроблене RSA Laboratories, визначає сумісні криптографічні формати даних і протоколи~\cite{pkcs1}. 
Ці стандарти забезпечують сумісність між різними криптографічними реалізаціями та сприяють безпечному обміну даними 
між гетерогенними системами.

\textbf{PKCS \#1} визначає схеми шифрування та підпису RSA, включаючи методи заповнення (PKCS\#1 v1.5 та OAEP), що 
запобігають різним криптоаналітичним атакам. Стандарт визначає формати даних для відкритих та закритих ключів RSA, 
зашифрованих повідомлень та цифрових підписів.

\textbf{PKCS \#3} описує протокол узгодження ключів Діффі-Хеллмана, що дозволяє двом сторонам встановити спільний секрет 
через незахищений канал. Цей стандарт визначає параметри домену та процедури походження ключів.

\textbf{PKCS \#5} визначає схеми шифрування на основі паролів, включаючи функції створення ключів (PBKDF2) які 
перетворюють паролі в криптографічні ключі з відповідною ентропією. Ці функції включають якількість ітерацій і 
salt values (випадкові дані додані до паролю перед шифруванням) для протидії атакам за словником.

\textbf{PKCS \#7} (зараз замінений на RFC 5652 Cryptographic Message Syntax) визначає формати для цифрового підпису, 
шифрування або автентифікації даних. Цей стандарт підтримує кілька алгоритмів підпису та шифрування, що забезпечує 
гнучкість політик безпеки.

\textbf{PKCS \#11} (Cryptoki) визначає незалежний від платформи API для криптографічних токенів, таких як смарт-карти 
та HSM. Цей стандарт дозволяє додаткам отримувати доступ до криптографічних служб без використання коду, специфічного 
для конкретного пристрою.

\textbf{PKCS \#12} визначає портативний формат для зберігання та передачі приватних ключів, сертифікатів та інших 
криптографічних даних, які зазвичай захищені шифруванням на основі пароля.

\subsection{Архітектура бібліотеки OpenSSL}

OpenSSL — це надійна реалізація протоколів SSL/TLS з відкритим кодом та універсальна бібліотека для реалізації криптографічних 
механізмів~\cite{openssl}. Бібліотека надає комплексні криптографічні функції, зокрема:

\textbf{Symmetric Cryptography:} Реалізація алгоритмів, включаючи AES, DES, 3DES, Blowfish, RC4 та ChaCha20, з 
підтримкою декількох режимів роботи (ECB, CBC, CFB, OFB, CTR, GCM).

\textbf{Asymmetric Cryptography:} Підтримка RSA, DSA, Diffie-Hellman та криптографії на еліптичних кривих (elliptic curve cryptography) 
(ECC). Хоча OpenSSL не включає вбудоване шифрування для ElGamal, бібліотека надає необхідні примітиви такі як модулярне 
піднесення до степеня, генерація простих чисел, генерація випадкових чисел для власне реалізації ElGamal.

\textbf{Hash Functions:} Реалізація сімейства MD5, SHA-1, SHA-2 (SHA-224, SHA-256, SHA-384, SHA-512) та SHA-3, а також 
кодів автентифікації повідомлень (HMAC).

\textbf{Certificate Management:} Генерація та аналіз сертифікатів X.509, підтримка операцій інфраструктури відкритих ключів

\textbf{Random Number Generation:} Криптографічно захищений генератор псевдовипадкових чисел (Cryptographically 
secure pseudorandom number generator -- CSPRNG), необхідний для генерації ключів та nonce creation.

Архітектура OpenSSL відокремлює криптографічні примітиви від реалізації протоколів, що дозволяє розробникам використовувати 
низькорівневі криптографічні функції для власних додатків, таких як реалізація криптосистеми ElGamal.

\section{Розробка Cryptographic Software}

\subsection{Вимоги до безпеки}

Реалізація криптографічних систем вимагає ретельної уваги до вимог безпеки, що виходять за межі алгоритмічної коректності:
\begin{itemize}
    \item \textbf{Управління ключами:} Безпечне генерування, зберігання, розподіл та знищення криптографічних ключів 
        є критично важливими питаннями безпеки. Ключі повинні генеруватися за допомогою криптографічно захищених генераторів 
        випадкових чисел з достатньою ентропією. Приватні ключі потребують захисту від несанкціонованого доступу за допомогою 
        шифрування, контролю доступу або апаратних модулів безпеки~\cite{ferguson2010}.
    \item \textbf{Генерація випадкових чисел:} Криптографічні операції залежать від високої якості випадковості. 
        Якщо випадкові числа є передбачуваними, то вони ставлять під загрозу безпеку, дозволяючи відновлення 
        ключів або підробку підписів. Операційні системи надають джерела ентропії з апаратних переривань, введення 
        користувача та шумів з навколишнього середовища, які криптографічні бібліотеки повинні належним чином збирати 
        та обробляти.
    \item \textbf{Стійкість до Side-Channel attack:} 
        Вразливості реалізації можуть призвести до витоку секретної інформації через коливання часу, споживання енергії, 
        електромагнітне випромінювання або моделі доступу до кешу. Алгоритми з постійним часом і безпечні практики 
        кодування зменшують ризик атак на основі часу~\cite{kocher1996}.
    \item \textbf{Атаки спричинені помилками:} Апаратні помилки, спричинені маніпуляціями з навколишнім середовищем 
        (перепади напруги, коливання температури, випромінювання), можуть призвести до розкриття секретних ключів 
        криптографічних реалізацій. Надійні механізми виявлення та перевірки помилок забезпечують захист від атак 
        через введення помилок~\cite{boneh1997}.
\end{itemize}

\subsection{Вибір параметрів}

Криптографічна безпека критично залежить від вибору параметрів. Для реалізації ElGamal:

\begin{itemize}
    \item \textbf{Вибір простих чисел:} просте число $p$ повинно мати розмір не менше 2048 bits для нинішньої безпеки, 
        а для довгострокового захисту рекомендується використовувати 3072 або 4096 bits. Просте число має бути 
        "safe prime"{} ($p = 2q + 1$ де $q$ також просте), щоб забезпечити велику підгрупу порядком простого числа.
    \item \textbf{Вибір генератора:} Генератор $g$ повинен мати великий порядок у мультиплікативній групі. Для 
        безпечних простих чисел вибір $g = 2$ або перевірка того $g^{q} \pmod p \neq 1$ забезпечує відповідний порядок.
    \item \textbf{Quality випадкових чисел:} Private key $x$ та ephemeral keys $k$ повинні генеруватися за допомогою 
        криптографічно захищених генераторів випадкових чисел. Повторне використання тимчасових ключів або використання 
        передбачуваних значень катастрофічно порушує безпеку.
\end{itemize}

\section{Вразливості в криптографічних реалізаціях}

\subsection{Механізми захисту в операційній системі}

Криптографічне програмне забезпечення залежить від служб безпеки окремої операційної системи, включаючи захист пам'яті, 
контроль доступу та ізоляцію процесів. Недосконалість цих механізмів створює такі вразливі місця:
\begin{enumerate}
    \item \textbf{Memory Disclosure:} Page file swapping може записувати криптографічні ключі на диск у вигляді
        звичайнісінького тексту. Дампи пам'яті, що генеруються під час збою системи або, навпаки, налагодження, можуть 
        потенційно розкрити конфіденційні дані. Функції безпечного розподілу пам'яті запобігають обміну та забезпечують 
        обнулення(очищення) пам'яті після використання.
    \item \textbf{Side-Channel Leakage attack:} Планування операційної системи та управління спільними ресурсами створюють
        канали синхронізації. Атаки на синхронізацію кешу використовують спільні кеші процесора для визначення криптографічних 
        ключів шляхом аналізу моделей доступу. Вразливості спекулятивного виконання (Spectre, Meltdown) обходять ізоляцію 
        пам'яті, потенційно можучи розкрити криптографічні матеріали.
    \item \textbf{Вразливості API:} Криптографічні API можуть містити деякі конструктивні недоліки, що завдяки яким 
        можливі зловживання. Неправильна обробка помилок може призвести до витоку інформації про приватні ключі через 
        повідомлення про помилки або різницю в часі між дійсними та недійсними операціями.
\end{enumerate}

\subsection{Атаки, залежно від реалізації}

Окрім алгоритмічної безпеки, безпека криптографічних систем багато чим залежить від реалізації:

\begin{enumerate}
    \item \textbf{Атака на синхронізацію (Timing Attacks):} Варіації часу виконання на основі секретних даних дозволяють 
        відновити ключ. Умовні розгалуження та залежний від даних доступ до пам'яті створюють канали синхронізації. 
        Сonstant time реалізації усувають залежні від даних варіації синхронізації~\cite{kocher1996}.
    \item \textbf{Buffer Overflow:} Порушення безпеки пам'яті дозволяють додавати код або отримувати довільний доступ 
        до пам'яті. Криптографічні бібліотеки повинні використовувати перевірку limits і безпечно управляти пам'яттю.
    \item \textbf{Атака на бічні канали:} Аналіз потужності та аналіз електромагнітного випромінювання дозволяють 
        відновити ключі з фізичних пристроїв. Бічні канали програмного забезпечення включають синхронізацію кешу, 
        прогнозування розгалужень та спекулятивне виконання.
    \item \textbf{Введення помилок(Fault Injection):} Включення(додавання) обчислювальної помилки під час криптографічних 
        операцій може призвести до розкриття секретного ключа. Надлишкові обчислення та виявлення помилок забезпечують 
        захист від атак з використанням computational~\cite{boneh1997}.
\end{enumerate}

\subsection{Оцінка стійкості криптосистеми до атак}

\begin{itemize}
    \item \textbf{Аналіз часу:} Статистичний аналіз часу виконання операцій для різних вхідних даних дозволяє 
        ідентифікувати канали часу. Перевірка з постійним часом забезпечує незалежність часу виконання від 
        вхідних даних.
    \item \textbf{Безпека пам'яті:} Регулярний аналіз виявляють переповнення буфера, вразливості використання після
        звільнення та інші проблеми пошкодження пам'яті.
    \item \textbf{Витік інформації:} Моніторинг системних журналів, повідомлень про помилки та результатів налагодження
        дозволяє виявити ненавмисне розкриття інформації і запобігти навмисному витоку.
\end{itemize}

\section{Практична реалізація Framework-у}

\subsection{Реалізація ElGamal за допомогою OpenSSL}

Реалізація криптосистеми ElGamal за допомогою OpenSSL вимагає використання арифметики великих чисел та засобів генерації 
випадкових чисел бібліотеки. Процес реалізації включає:

\textbf{Parameter Generation:} Використання функцій генерації простих чисел OpenSSL для створення безпечних простих 
чисел відповідного розміру. Функція \texttt{BN\_generate\_prime\_ex()} генерує прості числа певного розміру і властивостями.

\textbf{Key Pair Generation:} Вибір відповідних генераторів і обчислення відкритих ключів за допомогою модулярного 
піднесення до степеня за допомогою функції \texttt{BN\_mod\_exp()}. А private keys генеруються за допомоги 
криптографічно захищеного генератора випадкових чисел.

\textbf{Encryption Implementation:} Генерація ephemeral keys для кожної операції шифрування та виконання модульної 
арифметики для обчислення компонентів шифрованого тексту. Кодування повідомлень може вимагати схем заповнення для 
обробки повідомлень, коротших за модуль.

\textbf{Decryption Implementation:} Обчислення обернених за модулем з використанням функції \\ 
\texttt{BN\_mod\_inverse()} та виконання модульного множення для відновлення відкритого тексту.

\subsection{Методологія тестування безпеки}

Комплексне тестування безпеки оцінює алгоритмічну правильність і стійкість реалізації до атак:
\begin{itemize}
    \item 
    \textbf{Functional Testing:} Перевірка правильності шифрування та дешифрування для різних розмірів повідомлень 
        і ключових параметрів. Тестування граничних умов і обробки помилок.
    \textbf{Timing Analysis:} Вимірювання часу виконання операцій для виявлення залежностей від даних. Статистичний 
        аналіз визначає потенційні канали часу.
    \textbf{Тестування безпеки пам'яті:} Використання засобів очищення пам'яті (AddressSanitizer, MemorySanitizer) 
        для виявлення помилок пам'яті. Fuzzing із випадковими вхідними даними визначає умови збою.
    \textbf{Privilege Testing:} Оцінка захисту ключів за різних конфігурацій доступу користувачів
\end{itemize}

\section{Conclusion}

Безпека криптографічного програмного забезпечення виходить за межі алгоритмічної міцності і охоплює деталі
реалізації, вибір параметрів та стійкість до атак через побічні канали. Механізми захисту операційної системи
відіграють вирішальну роль у забезпеченні безпеки криптографічних операцій, проте недосконалість цих
механізмів створює потенційні вразливості. Атаки на реалізацію, включаючи аналіз часу, введення помилок та
розкриття пам'яті, загрожують навіть математично безпечним алгоритмам.

Практична реалізація криптосистеми ElGamal з використанням бібліотеки OpenSSL демонструє застосування
теоретичних принципів у розробці криптографічного програмного забезпечення в реальному світі. Ідеальна реалізація
повинна враховувати генерацію ключів, якість випадкових чисел, вибір параметрів та стійкість до атак через
побічні канали, а також дотримуватися встановлених стандартів.

Систематична оцінка стійкості криптографічного провайдера до атак, що використовують недоліки
механізмів захисту операційної системи, вимагає комплексного тестування, включаючи аналіз часу, перевірку
безпеки пам'яті та тестування ескалації привілеїв. Цей багатогранний підхід забезпечує надійну криптографічну
реалізацію, здатну захистити конфіденційну інформацію в сучасних обчислювальних середовищах.

\newpage

\selectlanguage{english}
\printbibliography

\appendix

\section{Скорочення}

\begin{description}
    \item[ASLR] Address Space Layout Randomization - Security technique that randomizes memory addresses
    \item[ASN.1] Abstract Syntax Notation One - Standard for describing data structures
    \item[CRT] Chinese Remainder Theorem - Optimization for RSA operations
    \item[DEP] Data Execution Prevention - Memory protection preventing code execution from data pages
    \item[CSP] Cryptographic Service Provider - CryptoAPI implementation module
    \item[DPAPI] Data Protection API - Windows API for encrypting user data
    \item[HSM] Hardware Security Module - Dedicated cryptographic hardware
    \item[IND-CCA2] Indistinguishability under Adaptive Chosen Ciphertext Attack
    \item[IND-CPA] Indistinguishability under Chosen Plaintext Attack
    \item[KSP] Key Storage Provider - CNG key storage implementation
    \item[OAEP] Optimal Asymmetric Encryption Padding - RSA padding scheme
    \item[PEM] Privacy Enhanced Mail - Base64 ASCII encoding format
    \item[PKCS] Public-Key Cryptography Standards - RSA Security standards
\end{description}
